import os
import numpy as np
import pandas as pd
from scipy.signal import resample
import torch
from torch.utils.data import Dataset

class TRAiLLDataset(Dataset):
    def __init__(self,
                 csv_path,
                 target_length=64,
                 onset_threshold_factor=0.5,
                 min_instance_length=5,
                 transform=None):
        """
        Args:
            csv_path (str): Path to the raw CSV file.
            target_length (int): Number of time steps to resample each instance to.
            onset_threshold_factor (float): Fraction of max derivative norm used to detect the gesture onset.
            min_instance_length (int): Minimum number of rows for an instance to be considered.
            transform (callable, optional): Optional transform to be applied on a sample.
        """
        self.csv_path = csv_path
        self.target_length = target_length
        self.onset_threshold_factor = onset_threshold_factor
        self.min_instance_length = min_instance_length
        self.transform = transform

        # Define a mapping for gesture labels
        self.label_map = {
            'open': 0,
            'fist': 1,
            'point': 2,
            'pinch': 3,
            'wave': 4,
            'trigger': 5,
            'grab': 6,
            'thumbs-up': 7,
            'swipe': 8,
        }

        # Load and process the data file
        self.instances = self._prepare_instances()

    def _prepare_instances(self):
        # Load the csv files
        df = pd.read_csv(self.csv_path)
        df.sort_values(by='timestamp', inplace=True)
        groups = df.groupby(df['status'].ne(df['status'].shift()).cumsum())

        instances = []
        for _, group in groups:
            label = group['status'].iloc[0]
            # Only consider groups that are long enough
            if len(group) < self.min_instance_length:
                continue

            # Extract channels
            sensor_data = group.iloc[:, 2:].values.astype(np.float32)

            # For non-'open' gestures, attempt to detect and align the true onset
            if label != 'open':
                sensor_data = self._align_onset(sensor_data)

            # Resample the sensor data to a fixed length on time axis
            sensor_data = resample(sensor_data, self.target_length, axis=0)

            # Normalize: per-channel z-score normalization
            mean = sensor_data.mean(axis=0)
            std = sensor_data.std(axis=0) + 1e-6  # avoid divided by zero
            sensor_data = (sensor_data - mean) / std

            instances.append({
                'features': sensor_data,
                'label': label
            })
        
        return instances

    def _align_onset(self, sensor_data):
        """
        A simple onset detection by computing the norm of the difference between consecutive samples.
        The first index where the derivative exceeds a fraction (onset_threshold_factor) of the maximum 
        derivative norm is chosen as the onset.
        """
        # Compute the Euclidean norm of the first difference (derivative) at each time step
        diff_norm = np.linalg.norm(np.diff(sensor_data, axis=0), axis=0)
        threshold = self.onset_threshold_factor * np.max(diff_norm)

        # Find the first index where the difference exceeds the threshold
        onset_indices = np.where(diff_norm > threshold)[0]
        if onset_indices.size > 0:
            onset_index = onset_indices[0]
            # Trim the data before the detected onset
            sensor_data = sensor_data[onset_index:]
        return sensor_data
    
    def __len__(self):
        return len(self.instances)
    
    def __getitem__(self, idx):
        instance = self.instances[idx]
        features = instance['features']  # shape: (target_length, num_channels)
        label_str = instance['label']
        label = self.label_map.get(label_str, -1)

        if self.transform:
            features = self.transform(features)

        # Convert to torch tensors
        features = torch.tensor(features, dtype=torch.float)
        label = torch.tensor(label, dtype=torch.long)

        return features, label